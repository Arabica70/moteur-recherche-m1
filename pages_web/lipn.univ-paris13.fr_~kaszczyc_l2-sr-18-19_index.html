<!DOCTYPE html><html><head><meta charset="UTF-8" /><link href="../resources/css/styles.css" rel="stylesheet" /><title>Antoine Kaszczyc</title></head><h1>L2 Info : Systèmes et réseaux 2018-19</h1><ul><li><a href="../index.html" >index site</a></li></ul><section><h1><span class="unicode" >&#x270d;</span>Ressources</h1><div><ul><li><a href="../resources/l2-sr-18-19/tp6-alt.pdf" >TP 6 alternatif, fichier PDF</a></li><li><a href="../resources/l2-sr-18-19/td8.pdf" >TD 8</a></li></ul></div></section><section><h1><span class="unicode" >&#x270d;</span>Sommaire des corrections</h1><div><ul><li><a href="#td1-ex3-q3" >TD 1, exercice 3, question 3</a></li><li><a href="#td2-ex3-q1" >TD 2, exercice 3, question 1</a></li><li><a href="#td3-ex1" >TD 3, exercice 1</a></li><li><a href="#td3-ex2.1" >TD 3, exercice 2.1</a></li><li><a href="#td4-ex3.4" >TD 4, exercice 3.4</a></li><li><a href="#td4-ex4" >TD 4, exercice 4</a></li><li><a href="#tp7" >TP 7</a></li></ul></div></section><section id="td1-ex3-q3" ><h1><span class="unicode" >&#x270d;</span>TD 1, exercice 3, question 3</h1><div><a href="../resources/l2-sr-18-19/td1-ex3-q3.c" >fichier C</a></div></section><section id="td2-ex3-q1" ><h1><span class="unicode" >&#x270d;</span>TD 2, exercice 3, question 1</h1><div><a href="../resources/l2-sr-18-19/td2-ex3-q1.c" >fichier C</a></div></section><section id="td3-ex1" ><h1><span class="unicode" >&#x270d;</span>TD 3, exercice 1</h1><div><section><h2><span class="unicode" >&#x270d;</span>SJF avec préemption</h2><div><p>On rappelle que le diagramme est normalement horizontal et ne contient que "temps" et "processus élu".</p><p>L'algorithme d'ordonnancement est comme suit (il s'exécute à chaque début de case) :</p><ol><li>Si soumission de Px, Px est ajouté aux processus en attente</li><li>Si terminaison de Px, Px est retiré</li><li>On regarde la durée estimée (sans compter la durée déjà exécutée) de tous les processus (élu + ceux en attente). Celui qui a la durée la plus petite est le nouvel élu. S'il y a un autre processus dans la case élu, ce dernier passe en attente. Si l'élu actuel est le nouvel élu, il reste élu.</li></ol><p>Les commentaires sont là pour décrire en partie ce que l'algorithme a fait à chaque case.</p><table><tr><th>temps</th><th>Processus élu</th><th>Processus en attente</th><th>Commentaires</th></tr><tr><td>0</td><td>P1</td><td>-</td><td>Soumission de P1 (durée 8)</td></tr><tr><td>1</td><td>P1</td><td>-</td><td>-</td></tr><tr><td>2</td><td>P2</td><td>{ P1 }</td><td>Soumission de P2 (durée 2)</td></tr><tr><td>3</td><td>P2</td><td>{ P1 }</td><td>-</td></tr><tr><td>4</td><td>P1</td><td>-</td><td>Terminaison de P2</td></tr><tr><td>5</td><td>P3</td><td>{ P1 }</td><td>Soumission de P3 (durée 5)</td></tr><tr><td>6</td><td>P4</td><td>{ P1, P3 }</td><td>Soumission de P4 (durée 3)</td></tr><tr><td>7</td><td>P5</td><td>{ P1, P3, P4 }</td><td>Soumission de P5 (durée 1)<br/>-</td></tr><tr><td>8</td><td>P4</td><td>{ P1, P3 }</td><td>Terminaison de P5</td></tr><tr><td>9</td><td>P4</td><td>{ P1, P3 }</td><td>-</td></tr><tr><td>10</td><td>P3</td><td>{ P1 }</td><td>Terminaison de P4</td></tr><tr><td>11</td><td>P3</td><td>{ P1 }</td><td>-</td></tr><tr><td>12</td><td>P3</td><td>{ P1 }</td><td>-</td></tr><tr><td>13</td><td>P3</td><td>{ P1 }</td><td>-</td></tr><tr><td>14</td><td>P1</td><td>-</td><td>Terminaison de P3</td></tr><tr><td>15</td><td>P1</td><td>-</td><td>-</td></tr><tr><td>16</td><td>P1</td><td>-</td><td>-</td></tr><tr><td>17</td><td>P1</td><td>-</td><td>-</td></tr><tr><td>18</td><td>P1</td><td>-</td><td>-</td></tr><tr><td>19</td><td>-</td><td>-</td><td>Terminaison de P1</td></tr></table></div></section><section><h2><span class="unicode" >&#x270d;</span>RR</h2><div><p>Le quantum vaut ici 2, c'est à dire qu'un processus reste élu 2 cases à la suite, sauf s'il termine avant.</p><p>L'algorithme d'ordonnancement est comme suit (il s'exécute à chaque début de case) :</p><ol><li>Si soumission de Px, ajout de Px en fin de file</li><li>Si terminaison de Px, Px est retiré</li><li>Si quantum de Px est terminé, ajout de Px en fin de file</li><li>Si la case élu est vide, et la file est non vide, le premier de la file est élu, avec quantum 2</li></ol><table><tr><th>temps</th><th>Processus élu</th><th>Processus en attente</th><th>Commentaires</th></tr><tr><td>0</td><td>P1</td><td>-</td><td>Soumission de P1 (durée 8)</td></tr><tr><td>1</td><td>P1</td><td>-</td><td>-</td></tr><tr><td>2</td><td>P2</td><td>> P1 ></td><td>Soumission de P2 (durée 2)<br/>Quantum de P1 terminé</td></tr><tr><td>3</td><td>P2</td><td>> P1 ></td><td>-</td></tr><tr><td>4</td><td>P1</td><td>-</td><td>Terminaison de P2</td></tr><tr><td>5</td><td>P1</td><td>> P3 ></td><td>Soumission de P3 (durée 5),</td></tr><tr><td>6</td><td>P3</td><td>> P1, P4 ></td><td>Soumission de P4 (durée 3)<br/>Quantum de P1 terminé</td></tr><tr><td>7</td><td>P3</td><td>> P5, P1, P4 ></td><td>Soumission de P5 (durée 1)</td></tr><tr><td>8</td><td>P4</td><td>> P3, P5, P1 ></td><td>Quantum de P3 terminé</td></tr><tr><td>9</td><td>P4</td><td>> P3, P5, P1 ></td><td>-</td></tr><tr><td>10</td><td>P1</td><td>> P4, P3, P5 ></td><td>Quantum de P4 terminé</td></tr><tr><td>11</td><td>P1</td><td>> P4, P3, P5 ></td><td>-</td></tr><tr><td>12</td><td>P5</td><td>> P1, P4, P3 ></td><td>Quantum de P1 terminé</td></tr><tr><td>13</td><td>P3</td><td>> P1, P4 ></td><td>Terminaison de P5</td></tr><tr><td>14</td><td>P3</td><td>> P1, P4 ></td><td>-</td></tr><tr><td>15</td><td>P4</td><td>> P3, P1 ></td><td>Quantum de P3 terminé</td></tr><tr><td>16</td><td>P1</td><td>> P3 ></td><td>Terminaison de P4</td></tr><tr><td>17</td><td>P1</td><td>> P3 ></td><td>-</td></tr><tr><td>18</td><td>P3</td><td>-</td><td>Terminaison de P1</td></tr><tr><td>19</td><td>-</td><td>-</td><td>Terminaison de P3</td></tr></table></div></section><section><h2><span class="unicode" >&#x270d;</span>Statistiques</h2><div><table><tr><th>Algorithme</th><th>temps moyen de traitement</th><th>temps moyen d'attente</th><th>temps moyen de réponse</th></tr><tr><td>SJF</td><td>7</td><td>3.2</td><td>0</td></tr><tr><td>RR</td><td>9</td><td>5.6</td><td>1.6</td></tr></table></div></section><section><h2><span class="unicode" >&#x270d;</span>SRTF avec préemption avec deux processeurs</h2><div><p>Les algorithmes fonctionnent de façon similaire mais il y a deux processus élus (différents) à la fois.</p><table><tr><th>temps</th><th>Processus élu 1</th><th>Processus élu 2</th><th>Processus en attente</th><th>Commentaires</th></tr><tr><td>0</td><td>P1</td><td>-</td><td>-</td><td>Soumission de P1 (durée 8)</td></tr><tr><td>1</td><td>P1</td><td>-</td><td>-</td><td>-</td></tr><tr><td>2</td><td>P1</td><td>P2</td><td>-</td><td>Soumission de P2 (durée 2)</td></tr><tr><td>3</td><td>P1</td><td>P2</td><td>-</td><td>-</td></tr><tr><td>4</td><td>P1</td><td>-</td><td>-</td><td>Terminaison de P2</td></tr><tr><td>5</td><td>P1</td><td>P3</td><td>-</td><td>Soumission de P3 (durée 5)</td></tr><tr><td>6</td><td>P1</td><td>P4</td><td>{ P3 }</td><td>Soumission de P4 (durée 3)</td></tr><tr><td>7</td><td>P1</td><td>P5</td><td>{ P3, P4 }</td><td>Soumission de P5 (durée 1)</td></tr><tr><td>8</td><td>P3</td><td>P4</td><td>-</td><td>Terminaison de P1<br/>Terminaison de P5</td></tr><tr><td>9</td><td>P3</td><td>P4</td><td>-</td><td>-</td></tr><tr><td>10</td><td>P3</td><td>-</td><td>-</td><td>Terminaison de P4</td></tr><tr><td>11</td><td>P3</td><td>-</td><td>-</td><td>-</td></tr><tr><td>12</td><td>-</td><td>-</td><td>-</td><td>Terminaison de P3</td></tr></table><p>statistiques :</p><table><tr><th>temps moyen de traitement</th><th>temps moyen d'attente</th><th>temps moyen de réponse</th></tr><tr><td>4.4</td><td>0.6</td><td>0</td></tr></table></div></section></div></section><section id="td3-ex2.1" ><h1><span class="unicode" >&#x270d;</span>TD 3, exercice 2.1</h1><div><p>Pour réussir cet exercice il faut tout d'abord avoir fait un essai de Round-Robin à plusieurs files. Faites donc un essai avec les algorithmes présentés. Si vous n'avez pas compris le mécanisme, vous ne pourrez pas répondre correctement à la question posée dans l'exercice.</p><p>On parle de famine quand un processus est en attente pour un temps infini. S'il doit attendre un temps très long mais fini, ce n'est pas une famine. <br/>Pour qu'une famine arrive il faut donc supposer qu'il y a de nouveaux processus créés à l'infini. Sinon, le processus en attente va bien finir par voir son tour arriver sur le processeur.<br/>Attention, on ne suppose pas qu'il y a une infinité de processus créés à un temps donné ! Ce qu'on suppose, c'est par exemple qu'à chaque temps est créé un processus de durée 2.<br/>En conséquence d'une telle supposition il est impossible de dessiner le diagramme complet : il y a toujours de nouveaux processus. On dessine donc des diagrammes incomplets, mais suffisament grands pour montrer un exemple de famine.</p><p>Le problème de la famine arrive donc quand les nouveaux processus ont toujours une priorité supérieure à celui en attente. Ce dernier (ou ces derniers, s'il y en a plusieurs en attente), ne verront jamais leur tour arriver, tant que des nouveaux processus sont créés. Voici un exemple :</p><table><tr><th>temps</th><th>Processus élu</th><th>File d'attente 1</th><th>File d'attente 2</th><th>Commentaires</th></tr><tr><td>0</td><td>P1</td><td>-</td><td>-</td><td>Soumission de P1 (durée 4)</td></tr><tr><td>1</td><td>P1</td><td>> P2 ></td><td>-</td><td>Soumission de P2 (durée 1)</td></tr><tr><td>2</td><td>P2</td><td>> P3 ></td><td>> P1 ></td><td>Soumission de P3 (durée 1)<br/>Quantum de P1 terminé</td></tr><tr><td>3</td><td>P3</td><td>> P4 ></td><td>> P1 ></td><td>Terminaison de P2<br/>Soumission de P4 (durée 1)</td></tr><tr><td>4</td><td>P4</td><td>> P5 ></td><td>> P1 ></td><td>Terminaison de P3<br/>Soumission de P5 (durée 1)</td></tr><tr><td>5</td><td>P5</td><td>> P6 ></td><td>> P1 ></td><td>Terminaison de P4<br/>Soumission de P6 (durée 1)</td></tr><tr><td>...</td><td>...</td><td>...</td><td>> P1 ></td><td>...</td></tr><tr><td>n</td><td>Pn</td><td>> P(n+1) ></td><td>> P1 ></td><td>Terminaison de P(n-1)<br/>Soumission de P(n+1) (durée 1)</td></tr></table><p>Pour résoudre ce problème, on peut penser à plusieurs solutions :</p><ul><li>faire en sorte que les processus existants (en attente) aient une priorité supérieure aux processus nouveaux arrivants. Par exemple, on peut placer un processus arrivant en tout dernier (pas seulement dernier de la première file, mais derrière tout processus en attente dans toute file). On peut aussi, au lieu de faire descendre la prioriété d'un processus qui quitte la place d'élu, augmenter sa file au lieu de décrémenter sa file, et placer les nouveaux arrivants en dernière file.</li><li>garder le placement dans les files existants, mais modifier la fonction SCHEDULE afin qu'elle ne sélectionne pas toujours le premier de la première file, mais qu'elle sélectionne parfois le premier des autres files. Par exemple, 50% du temps la première file, 25% du temps la deuxième, etc...</li><li>vous pouvez aussi avoir d'autres idées. L'essentiel est de conserver l'ordonnancement RR et les files multiples, afin de respecter l'énoncé de l'exercice. Vous pouvez changer le reste comme vous voulez.</li></ul></div></section><section id="td4-ex3.4" ><h1><span class="unicode" >&#x270d;</span>TD 4, exercice 3.4</h1><div><p>On cherche à déterminer le nombre de niveaux nécessaires pour stocker la table des pages. Pour rappel, la table des pages doit être stockée, comme n'importe quelle donnée, dans la mémoire. Puisqu'on organise la mémoire sous forme de cadre, la table des pages se plie aussi à cette règle. Ainsi, la table des pages peut devoir être stockée sur plusieurs cadres. </p><pre>Soit SC la taille en octets d'un cadre.
Soit STP la taille en octets de la table des pages.
Soit NCTP = STP/SC le nombre de cadres nécessaires
                  pour représenter la table des pages en mémoire.</pre><p>On souhaite organiser ces multiples cadres sous la forme d'un arbre. C'est à dire qu'on souhaite indexer les multiples cadres dans un seul cadre, ce qui revient à créer ce qu'on peut nommer un sommaire.</p><p>Pour cela, en plus des NCTP cadres, on va créer des cadres supplémentaires pour le sommaire. On appelle le sommaire : la table de la table des pages.</p><p>Imaginons (pour donner un exemple simple) qu'on a 24 adresses à placer dans la table des pages, et qu'un cadre peut stocker 4 adresses. Voici les cadres de la table (on n'a pas encore construit le sommaire) :</p><img src="../resources/l2-sr-18-19/tablepages1.png" /><p>L'algorithme consiste à poser la question : combien de cadre ai-je besoin pour référencer (établir le sommaire de) ces 6 cadres de la table des pages ?<br/>j'ai 6 cadres donc 6 adresses à référencer. Comme un cadre peut contenir 4 adresses, j'ai donc besoin de 2 cadres.<br/>On obtient :</p><img src="../resources/l2-sr-18-19/tablepages2.png" /><p>On a deux cadres de sommaire de niveau 1. <br/>On recommence l'algorithme. Combien de cadres ai-je besoin pour référencer mes deux cadres de sommaire de niveau 1 ? Il m'en faut 1 : </p><img src="../resources/l2-sr-18-19/tablepages3.png" /><p>En conclusion, j'ai 6 cadres de bases, 2 cadres de sommaire de niveau 1, et 1 cadre de sommaire de niveau 2. Celà fait en tout 9 cadres pour représenter la table des pages complète.</p><p>Comment fonctionne le sommaire ? Le cadre 7 de sommaire de niveau 1 représente des intervalles. La première ligne du cadre 7 référence le cadre 1, qui référence les pages 1, 2, 3 et 4. La seconde ligne du cadre 7 référence le cadre 2, qui référence les pages 5, 6, 7 et 8. La première ligne du cadre 7 référence donc l'intervalle de pages 1 à 4, la seconde ligne l'intervalle 5 à 8, etc. Quand au cadre 9, sa première ligne référence le cadre 9, autrement dit l'intervalle de pages 1 à 16. Lorsqu'on cherche l'adresse associéé à une page, on suit donc les intervalles jusqu'à arriver à un cadre de base qui contient l'adresse associée à la page.</p><p>Enfin rappelez-vous que les pages sont des conceptions symboliques qui désignent des cadres. Les pages d'un programme sont contigües (page 1, page 2, page 3...) alors que les adresses des cadres respectifs ne le sont pas nécessairement (page 1 -> cadre @13, page 2 -> cadre @45, page 3 -> cadre @89...)</p></div></section><section id="td4-ex4" ><h1><span class="unicode" >&#x270d;</span>TD 4, exercice 4</h1><div><ul><li>668</li><li>1353</li><li>1354</li><li>dépasse la longueur, erreur</li><li>2936</li><li>1076</li><li>dépasse la longueur, erreur</li></ul></div></section><section id="tp7" ><h1><span class="unicode" >&#x270d;</span>TP 7</h1><div><p>Je vous conseille d'utiliser la commande <span class="code" >netstat -uapnc</span> pour obtenir des informations sur les sockets UDP ouvertes.</p><ul><li><a href="../resources/l2-sr-18-19/serveur-udp.c" >Serveur UDP en C</a></li><li><a href="../resources/l2-sr-18-19/client-udp.c" >Client UDP en C</a></li></ul></div></section><footer><p>Site réalisé statiquement en Scala, HTML et CSS.<br/>Faut pas se casser la tête pour afficher du texte...</p></footer></html>